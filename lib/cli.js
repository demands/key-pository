// Generated by CoffeeScript 1.7.1
(function() {
  var EMAIL_REGEXP, EXPECTED_OWNER, Heroku, argv, fibrous, fs, glob, path,
    __slice = [].slice;

  fs = require('fs');

  path = require('path');

  glob = require('glob');

  fibrous = require('fibrous');

  Heroku = require('heroku-client');

  argv = require('yargs').options('token', {
    alias: 't',
    demand: true
  }).options('commit', {
    alias: 'c',
    boolean: true,
    "default": false
  }).usage('Synchronizes all of the heroku app collaborators using email addresses in the local key files.\nUsage: $0').argv;

  EMAIL_REGEXP = /^[^@]+@[^@.]+[.][^@]+$/;

  EXPECTED_OWNER = 'admin@goodeggsinc.com';

  fibrous.run(function() {
    var app, collaborator, collaborators, comment, content, email, hash, heroku, key, owner, pubfile, pubfiles, type, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _results;
    collaborators = [];
    pubfiles = glob.sync(path.resolve(path.join(__dirname, '..', 'keys', '*.pub')));
    for (_i = 0, _len = pubfiles.length; _i < _len; _i++) {
      pubfile = pubfiles[_i];
      content = fs.sync.readFile(pubfile);
      _ref = content.toString().split(' '), type = _ref[0], key = _ref[1], comment = 3 <= _ref.length ? __slice.call(_ref, 2) : [];
      comment = comment.join(' ').trim();
      if (!comment.match(EMAIL_REGEXP)) {
        console.log("ignoring " + pubfile + ": comment isn't an email address");
        continue;
      }
      collaborators.push(comment);
    }
    heroku = new Heroku({
      token: argv.token
    });
    _ref1 = heroku.apps().sync.list();
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      app = _ref1[_j];
      owner = app.owner.email;
      if (owner !== EXPECTED_OWNER) {
        console.error("skipping " + app.name + " because owner is " + owner + " (expected: " + EXPECTED_OWNER + ")");
        continue;
      } else {
        console.log(app.name);
      }
      app = heroku.apps(app.name);
      hash = {};
      for (_k = 0, _len2 = collaborators.length; _k < _len2; _k++) {
        email = collaborators[_k];
        hash[email] = 1;
      }
      _ref2 = app.collaborators().sync.list();
      for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
        collaborator = _ref2[_l];
        if ((hash[collaborator.user.email] != null) || collaborator.user.email === owner) {
          console.log("    " + collaborator.user.email);
          delete hash[collaborator.user.email];
        } else {
          console.log("  - " + collaborator.user.email);
          if (argv.commit) {
            app.collaborators(collaborator.user.email).sync["delete"]();
          }
        }
      }
      _results.push((function() {
        var _results1;
        _results1 = [];
        for (email in hash) {
          console.log("  + " + email);
          if (argv.commit) {
            _results1.push(app.collaborators().sync.create({
              user: {
                email: email
              }
            }));
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      })());
    }
    return _results;
  });

}).call(this);
